IF OBJECT_ID('PURCHASEORDER3778') IS NOT NULL
DROP TABLE PURCHASEORDER3778;

IF OBJECT_ID('INVENTORY3778') IS NOT NULL
DROP TABLE INVENTORY3778;

IF OBJECT_ID('ORDERLINE3778') IS NOT NULL
DROP TABLE ORDERLINE3778;

IF OBJECT_ID('ORDER3778') IS NOT NULL
DROP TABLE [ORDER3778];

IF OBJECT_ID('AUTHORISEDPERSON3778') IS NOT NULL
DROP TABLE AUTHORISEDPERSON3778;

IF OBJECT_ID('ACCOUNTPAYMENT3778') IS NOT NULL
DROP TABLE ACCOUNTPAYMENT3778;

IF OBJECT_ID('CLIENTACCOUNT3778') IS NOT NULL
DROP TABLE CLIENTACCOUNT3778;

IF OBJECT_ID('PRODUCT3778') IS NOT NULL
DROP TABLE PRODUCT3778;

IF OBJECT_ID('LOCATION3778') IS NOT NULL
DROP TABLE [LOCATION3778];

IF OBJECT_ID('GENERALLEDGER3778') IS NOT NULL
DROP TABLE GENERALLEDGER3778;

GO

CREATE TABLE GENERALLEDGER3778(
    ITEMID INTEGER,
    DESCRIPTION NVARCHAR(100),
    AMOUNT MONEY,
    CONSTRAINT PK_GENERALLEDGER PRIMARY KEY (ITEMID),
    CONSTRAINT UQ_GENERALEDGER_DESCRIPTION UNIQUE(DESCRIPTION)
);

INSERT INTO GENERALLEDGER3778 (ITEMID, DESCRIPTION, AMOUNT) VALUES
(1, 'ASSETSCASH', 100000.00),
(2, 'ASSETSSTOCK', 0),
(3, 'ASSETSACCOUNT', 0);

CREATE TABLE [LOCATION3778](
    LOCATIONID NVARCHAR(8),
    LOCNAME NVARCHAR(50) NOT NULL,
    ADDRESS NVARCHAR(200) NOT NULL,
    MANAGER NVARCHAR(100),
    CONSTRAINT PK_LOCATION PRIMARY KEY (LOCATIONID)
);

CREATE TABLE PRODUCT3778(
    PRODUCTID INTEGER IDENTITY(10001, 1),
    PRODNAME NVARCHAR(100) NOT NULL,
    BUYPRICE MONEY,
    SELLPRICE MONEY,
    CONSTRAINT PK_PRODUCT PRIMARY KEY(PRODUCTID),
    CONSTRAINT CHK_WHOLESALE_RETAIL CHECK(BUYPRICE < SELLPRICE)
);

CREATE TABLE CLIENTACCOUNT3778(
    ACCOUNTID INTEGER IDENTITY(30001, 1),
    ACCTNAME NVARCHAR(100) NOT NULL,
    BALANCE MONEY NOT NULL,
    CREDITLIMIT MONEY NOT NULL,
    CONSTRAINT PK_CLIENTACCOUNT PRIMARY KEY(ACCOUNTID),
    CONSTRAINT CHK_CLIENTACCOUNT_BALANCE_CREDIT CHECK(BALANCE<=CREDITLIMIT),
    CONSTRAINT UQ_CLENTACCOUNT_NAME UNIQUE(ACCTNAME)
);

CREATE TABLE ACCOUNTPAYMENT3778(
    ACCOUNTID INTEGER,
    DATETIMERECEIVED DATETIME,
    AMOUNT MONEY NOT NULL,
    CONSTRAINT PK_ACCOUNTPAYMENT PRIMARY KEY(ACCOUNTID, DATETIMERECEIVED),
    CONSTRAINT FK_ACCOUNTPAYMENT_ACCOUNT FOREIGN KEY (ACCOUNTID) REFERENCES CLIENTACCOUNT3778,
    CONSTRAINT CHK_ACCOUNTPAYMENT_AMOUNT CHECK(AMOUNT >0)
);

CREATE TABLE AUTHORISEDPERSON3778(
    USERID INTEGER IDENTITY(50001, 1),
    FIRSTNAME NVARCHAR(100) NOT NULL,
    SURNAME NVARCHAR(100) NOT NULL,
    EMAIL NVARCHAR(100) NOT NULL,
    [PASSWORD] NVARCHAR(100) NOT NULL,
    ACCOUNTID INTEGER NOT NULL,
    CONSTRAINT PK_AUTHORISEDPERSON PRIMARY KEY(USERID),
    CONSTRAINT FK_AUTHORISEDPERSON_CLIENTACCOUNT FOREIGN KEY(ACCOUNTID) REFERENCES CLIENTACCOUNT3778,
    CONSTRAINT CHK_AUTHORISEDPERSON_EMAIL CHECK(EMAIL LIKE '%@%')
);

CREATE TABLE [ORDER3778](
    ORDERID INTEGER IDENTITY(70001, 1),
    SHIPPINGADDRESS NVARCHAR(200) NOT NULL,
    DATETIMECREATED DATETIME NOT NULL,
    DATETIMEDISPATCHED DATETIME,
    TOTAL MONEY NOT NULL,
    USERID INTEGER NOT NULL,
    CONSTRAINT PK_ORDER PRIMARY KEY(ORDERID),
    CONSTRAINT FK_ORDER_AUTHORISEDPERSON FOREIGN KEY(USERID) REFERENCES AUTHORISEDPERSON3778,
    CONSTRAINT CHK_ORDER_TOTAL CHECK(TOTAL >= 0)
);


CREATE TABLE ORDERLINE3778(
    ORDERID INTEGER,
    PRODUCTID INT,
    QUANTITY INT NOT NULL,
    DISCOUNT DECIMAL (3,2) DEFAULT 0,
    SUBTOTAL MONEY NOT NULL,
    CONSTRAINT PK_ORDERLINE PRIMARY KEY(ORDERID, PRODUCTID),
    CONSTRAINT FK_ORDERLINE_ORDER FOREIGN KEY(ORDERID) REFERENCES [ORDER3778],
    CONSTRAINT FK_ORDERLINE_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT3778,
    CONSTRAINT CHK_ORDER_DISCOUNT CHECK(DISCOUNT >=0 AND DISCOUNT <= 0.25),
    CONSTRAINT CHK_ORDERLINE_SUBTOTAL CHECK(SUBTOTAL > 0)
);

CREATE TABLE INVENTORY3778(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    NUMINSTOCK INTEGER NOT NULL,
    CONSTRAINT PK_INVENTORY PRIMARY KEY(PRODUCTID, LOCATIONID),
    CONSTRAINT FK_INVENTORY_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT3778,
    CONSTRAINT FK_INVENTORY_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION3778,
    CONSTRAINT CHK_INVENTORY_NUMINSTOCK CHECK(NUMINSTOCK >=0)
);

CREATE TABLE PURCHASEORDER3778(
    PRODUCTID INT,
    LOCATIONID NVARCHAR(8),
    DATETIMECREATED DATETIME,
    QUANTITY INTEGER,
    TOTAL MONEY,
    CONSTRAINT PK_PURCHASEORDER PRIMARY KEY(PRODUCTID, LOCATIONID, DATETIMECREATED),
    CONSTRAINT FK_PURCHASEORDER_PRODUCT FOREIGN KEY(PRODUCTID) REFERENCES PRODUCT3778,
    CONSTRAINT FK_PURCHASEORDER_LOCATION FOREIGN KEY(LOCATIONID) REFERENCES LOCATION3778,
    CONSTRAINT CHK_PURCHASEORDER_QUANTITY CHECK(QUANTITY > 0)
);

GO


--SELECT * FROM SYS.TABLES;

--------------------------

-- SET UP LOCATION, PRODUCT AND INVENTORY
BEGIN

    INSERT INTO LOCATION3778(LOCATIONID, LOCNAME, ADDRESS, MANAGER)VALUES
    ('MLB3931', 'Melbourne South East', '123 Demon Street, Mornington, 3931', 'Bruce Wayne');

    INSERT INTO PRODUCT3778(PRODNAME, BUYPRICE, SELLPRICE) VALUES
    ('APPLE ME PHONE X', '890.00', 1295.00 );

    DECLARE @PRODID INT = @@IDENTITY;

    INSERT INTO INVENTORY3778(PRODUCTID, LOCATIONID, NUMINSTOCK) VALUES
    (@PRODID, 'MLB3931', 0);

    -- ADD A NEW CLIENT ACCOUNT AND A NEW AUTHORISED USER FOR THAT ACCOUNT

    INSERT INTO CLIENTACCOUNT3778(ACCTNAME, BALANCE, CREDITLIMIT) VALUES
    ('FREDS LOCAL PHONE STORE', '0', 10000.00 );

    DECLARE @ACCOUNTID INT = @@IDENTITY;

    INSERT INTO AUTHORISEDPERSON3778(FIRSTNAME, SURNAME, EMAIL, [PASSWORD], ACCOUNTID) VALUES
    ('Fred', 'Flintstone', 'fred@fredsphones.com', 'secret', @ACCOUNTID);

    DECLARE @USERID INT = @@IDENTITY;

    -----------

    -- BUY SOME STOCK

    -- ADD A PURCHASE ORDER ROW
    INSERT INTO PURCHASEORDER3778(PRODUCTID, LOCATIONID, DATETIMECREATED, QUANTITY, TOTAL) VALUES
    (@PRODID,  'MLB3931', '10-Apr-2020', 50, 44500.00);

    -- UPDATE OUR INVENTORY FOR THAT STOCK
    UPDATE INVENTORY3778 SET NUMINSTOCK = 50 WHERE PRODUCTID = @PRODID AND LOCATIONID = 'MLB3931';

    -- UPDATE THE GENERAL LEDGER INCREASING THE VALUE OF OUR STOCK ASSETS AND DECREASING THE CASH ASSETS
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT - 44500.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT + 44500.00 WHERE DESCRIPTION = 'ASSETSSTOCK';

    -----------

    -- CUSTOMER MAKES AN ORDER - (INITIALLY THE ORDER IS NOT FULFILLED)

    INSERT INTO ORDER3778(SHIPPINGADDRESS, DATETIMECREATED, DATETIMEDISPATCHED, TOTAL, USERID) VALUES
    ('7 Lucky Strike, Bedrock, USB, 1111', '20-Apr-2020', NULL, 6151.25, @USERID);

    DECLARE @ORDERID INT = @@IDENTITY;

    INSERT INTO ORDERLINE3778(ORDERID, PRODUCTID, QUANTITY, DISCOUNT, SUBTOTAL) VALUES
    (@ORDERID, @PRODID, 5, 0.05, '6151.25');

    -- WE FULLFILL THE ORDER

    -- UPDATE THE ORDER TO GIVE IT A FULLFUILLED DATE
    UPDATE ORDER3778 SET DATETIMEDISPATCHED = '21-Apr-2020' WHERE ORDERID = @ORDERID;

    -- UPDATE THE CLIENTS ACCOUNT BALANCE TO INCLUDE THE VALUE OF THE ORDER
    UPDATE CLIENTACCOUNT3778 SET BALANCE = BALANCE + 6151.25 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER INCREASING VALUE OF ACCOUNTS, DECEASING VALUE OF STOCK
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT + 6151.25  WHERE DESCRIPTION = 'ASSETSACCOUNT';
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT - (5*890) WHERE DESCRIPTION = 'ASSETSSTOCK';

    -------------

    -- CLIENT MAKES AN ACCOUNT OFF THIER ACCOUNT BALANCE

    -- ADD A ROW TO ACCOUNTPAYMENT3778
    INSERT INTO ACCOUNTPAYMENT3778(ACCOUNTID, DATETIMERECEIVED, AMOUNT) VALUES
        (@ACCOUNTID, '25-Apr-2020', '2000.00');

    -- UPDATE THE CLIENT ACCOUNT TO REFLECT THE BALANCE CHANGE
    UPDATE CLIENTACCOUNT3778 SET BALANCE = BALANCE - 2000.00 WHERE ACCOUNTID = @ACCOUNTID;

    -- UPDATE THE GENERAL LEDGER - INCREASE ASSETSCASH AND DECREASE ASSETS ACCOUNT
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT + 2000.00 WHERE DESCRIPTION = 'ASSETSCASH';
    UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT - 2000.00 WHERE DESCRIPTION = 'ASSETSACCOUNT';
END;

GO
----------------------------


IF OBJECT_ID('ADD_LOCATION') IS NOT NULL
DROP PROCEDURE ADD_LOCATION;
GO
--------------------  ADD_LOCATION --------------------

-- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
-- insert the specified values into the table LOCATION3778
-- ADD A ROW FOR THIS LOCATION TO THE INVENTORY3778 TABLE **FOR EACH** PRODUCT IN THE PRODUCT3778 TABLE
-- I.E. IF THERE ARE 4 PRODUCTS THIS WILL BE 4 NEW ROWS IN THE INVENTORY TABLE
-- RETURN THE LOCID OF THE NEW LOCATION

-- EXCEPTIONS
-- if the location id is a duplicate throw error: number 51001  message : 'Duplicate Location ID'
-- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE ADD_LOCATION @PLOCID NVARCHAR(10), @PLOCNAME NVARCHAR(50),
@PLOCADDRESS NVARCHAR(200), @PMANAGER NVARCHAR(100),
@LOCID NVARCHAR(10) OUTPUT AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            INSERT INTO LOCATION3778 (LOCATIONID, LOCNAME, ADDRESS, MANAGER)
            VALUES(@PLOCID, @PLOCNAME, @PLOCADDRESS, @PMANAGER)

            DECLARE @MyCursor CURSOR;
            DECLARE @ProdID INT;
            SET @MyCursor = CURSOR FOR SELECT PRODUCTID FROM PRODUCT3778

            OPEN @MyCursor
            FETCH NEXT FROM @MyCursor INTO @ProdID

            WHILE @@FETCH_STATUS = 0
                BEGIN
                    INSERT INTO INVENTORY3778 (PRODUCTID, LOCATIONID, NUMINSTOCK)
                    VALUES (@ProdID, @PLOCID, 0)
                    FETCH NEXT FROM @MyCursor INTO @ProdID
                END

            CLOSE @MyCursor ;
            DEALLOCATE @MyCursor;
            SET @LOCID = @PLOCID

            COMMIT TRAN

        END TRY
        BEGIN CATCH
            ROLLBACK TRAN

            IF  ERROR_NUMBER() = 2627            
                THROW 51001, 'Duplicate Location ID', 1        
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH
END;
GO


IF OBJECT_ID('GET_LOCATION_BY_ID') IS NOT NULL
DROP PROCEDURE GET_LOCATION_BY_ID ;
GO

--------------------  GET_LOCATION_BY_ID  --------------------

    -- return the specified location.

    -- EXCEPTIONS
    -- if the location id is invalid throw error: number 51002  message : 'Location Doesnt Exist'
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE GET_LOCATION_BY_ID @PLOCID NVARCHAR(8),
@MyCursor CURSOR VARYING OUTPUT  AS
BEGIN
    BEGIN TRY
                IF NOT EXISTS(SELECT * FROM LOCATION3778 WHERE LOCATIONID = @PLOCID)
                    THROW 51002, 'Location Doesnt Exist', 1;

                SET @MyCursor = CURSOR FOR SELECT * FROM LOCATION3778 WHERE LOCATIONID = @PLOCID

                OPEN @MyCursor;

    END TRY
    BEGIN CATCH
            IF  ERROR_NUMBER() = 51002            
                THROW
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
    END CATCH
END;
GO


IF OBJECT_ID('ADD_PRODUCT') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT ;
GO

--------------------  ADD_PRODUCT  --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table PRODUCT3778
    -- ADD A ROW FOR THIS PRODUCT TO THE INVENTORY3778 TABLE **FOR EACH** LOCTAION IN THE LOCATION3778 TABLE
    -- I.E. IF THERE ARE 4 LOCATIONS THIS WILL BE 4 NEW ROWS IN THE INVENTORY TABLE
    -- RETURN THE NEW PRODUCTS PRODUCTID

    -- EXCEPTIONS
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE ADD_PRODUCT @PPRODNAME NVARCHAR(100), @PBUYPRICE MONEY, @PSELLPRICE MONEY AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            INSERT INTO PRODUCT3778 (PRODNAME, BUYPRICE, SELLPRICE)
            VALUES (@PPRODNAME, @PBUYPRICE, @PSELLPRICE);

            DECLARE @MyCursor CURSOR;
            DECLARE @LocID NVARCHAR(10);
            SET @MyCursor = CURSOR FOR SELECT LOCATIONID FROM LOCATION3778;

            OPEN @MyCursor;
            FETCH NEXT FROM @MyCursor INTO @LocID;

            WHILE @@FETCH_STATUS = 0
                BEGIN
                    INSERT INTO INVENTORY3778 (PRODUCTID, LOCATIONID, NUMINSTOCK)
                    VALUES (@@IDENTITY, @LocID, 0);
                    FETCH NEXT FROM @MyCursor INTO @LocID;
                END

            CLOSE @MyCursor ;
            DEALLOCATE @MyCursor;

            COMMIT TRAN
            RETURN @@IDENTITY;
            
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            BEGIN                
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                THROW 50000, @ERRORMESSAGE, 1            
            END 
        END CATCH
END;
GO


IF OBJECT_ID('GET_PRODUCT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_PRODUCT_BY_ID ;
GO

--------------------  GET_PRODUCT_BY_ID  --------------------

    -- return the specified PRODUCT. -- What are we returning?

    -- EXCEPTIONS
    -- if the PRODUCT id iis invalid throw error: number 52002  message : 'Product Doesnt Exist'
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE GET_PRODUCT_BY_ID @PPRODID INT, @MyCursor CURSOR VARYING OUTPUT AS
BEGIN
    BEGIN TRY
        IF EXISTS(SELECT * FROM PRODUCT3778 WHERE PRODUCTID = @PPRODID)
            BEGIN
                SET @MyCursor = CURSOR FOR SELECT * FROM PRODUCT3778 WHERE PRODUCTID = @PPRODID

                OPEN @MyCursor;
            END
            
    ELSE
        BEGIN
            ;THROW 52002, 'Product Doesnt Exist', 1;
        END
    END TRY
    BEGIN CATCH
            IF  ERROR_NUMBER() = 52002            
                THROW;
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
    END CATCH
END;
GO


IF OBJECT_ID('PURCHASE_STOCK') IS NOT NULL
DROP PROCEDURE PURCHASE_STOCK;
GO

--------------------  PURCHASE_STOCK --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION

    -- insert the A ROW TO THE PURCHASE ORDER TABLE
    -- USE THE CURRENT SYSTEM DATETIME AS FOR THE DATETIMECREATED FIELD
    -- CALCULATE THE TOTAL BASED ON THE BUYPRICE OF THE PRODUCT SPECIFICED AND THE QUANTITY IN @PQTY
    -- UPDATE INVENTORY3778 FOR THE SPECIFIED PRODUCT IN THE SPECIFIED LOCATION BY THE QTY PURCHASED
    -- DECREASE THE ASSETCASH ROW IN THE GENERAL LEDGER BY THE TOTAL AMOUNT OF THE ORDER
    -- INCREASE THE ASSETSTOCK ROW IN THE GENERAL LEDGER BY THE TOTAL AMOUNT OF THE ORDER

    -- EXCEPTIONS
    -- if the LOCATUON id is invalid throw error: number 51002  message : 'Location Doesnt Exist'
    -- if the PRODUCT id is invalid throw error: number 52002  message : 'Product Doesnt Exist'
    -- IF THERE IS INSUFFICIENT ASSETSCASH IN THE GENERAL LEDGER THEN THROW ERROR: 59001 MESSAGE : 'INSUFFICIENT CASH'
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE PURCHASE_STOCK @PPRODID INT, @PLOCID NVARCHAR(10), @PQTY INT AS
BEGIN
    BEGIN TRAN
        BEGIN TRY

            DECLARE @BuyP MONEY;
            SET @BuyP = (SELECT BUYPRICE FROM PRODUCT3778 WHERE PRODUCTID = @PPRODID);

            IF NOT EXISTS (SELECT * FROM LOCATION3778 WHERE LOCATIONID = @PLOCID)
                THROW 51002, 'Location Doesnt Exist', 1;
            IF NOT EXISTS (SELECT * FROM PRODUCT3778 WHERE PRODUCTID = @PPRODID)
                THROW 52002, 'Product Doesnt Exist', 1;
            IF ((SELECT AMOUNT FROM GENERALLEDGER3778 WHERE ITEMID = 1) < (@PQty * @BuyP))
            THROW 59001, 'INSUFFICIENT CASH', 1;

            INSERT INTO PURCHASEORDER3778 (PRODUCTID, LOCATIONID, DATETIMECREATED, QUANTITY, TOTAL)
            VALUES (@PPRODID, @PLOCID, GETDATE(), @PQTY, (@PQty * @BuyP))

            UPDATE INVENTORY3778 SET NUMINSTOCK = NUMINSTOCK + @PQTY 
            WHERE LOCATIONID = @PLOCID AND PRODUCTID = @PPRODID;

            UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT - (@PQty * @BuyP) WHERE ITEMID = 1;

            UPDATE GENERALLEDGER3778 SET AMOUNT = AMOUNT + @PQTY WHERE ITEMID = 2;

            COMMIT TRAN
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
                IF  ERROR_NUMBER() = 51002 OR ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 59001
                    THROW;
                ELSE 
                    BEGIN                
                        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                        THROW 50000, @ERRORMESSAGE, 1            
                    END  
        END CATCH
END;
GO

IF OBJECT_ID('ADD_CLIENT_ACCOUNT') IS NOT NULL
DROP PROCEDURE ADD_CLIENT_ACCOUNT;
GO

--------------------  ADD_CLIENT_ACCOUNT --------------------

    -- insert the specified values into the table CLIENTACCOUNT3778
    -- RETURN THE NEW ACCOUNTS ACCOUNTID

    -- EXCEPTIONS
    -- ACCOUNT NAME ALREADY EXISTS - SEE TABLE CONSTRAINTS - THROW ERROR 53001 : DUPLICATE ACCOUNT NAME
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE ADD_CLIENT_ACCOUNT @PACCTNAME NVARCHAR(100), @PBALANCE MONEY, @PCREDITLIMIT MONEY AS
BEGIN
    BEGIN TRAN
        BEGIN TRY

            INSERT INTO CLIENTACCOUNT3778 (ACCTNAME, BALANCE, CREDITLIMIT)
            VALUES (@PACCTNAME, @PBALANCE, @PCREDITLIMIT);

            COMMIT TRAN
            
            RETURN @@IDENTITY;
            
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN

            IF  ERROR_NUMBER() = 2627 -- 2627 is a violation of unique constraint    
                THROW 53001, 'Duplicate Account Name', 1        
            ELSE
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH

END;
GO

IF OBJECT_ID('ADD_AUTHORISED_PERSON') IS NOT NULL
DROP PROCEDURE ADD_AUTHORISED_PERSON;

GO

--------------------  ADD_AUTHORISED_PERSON  --------------------

    -- insert the specified values into the table AUTHORISEDPERSON3778
    -- RETURN THE NEW USERS USER ID

    -- EXCEPTIONS
    -- EMAIL IS INVALID (DOESN'T CONTAIN AN @ - SEE TABLE CONSTRAINTS)  - THROW ERROR 53003 : INVALID EMAIL ADDRESS
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE ADD_AUTHORISED_PERSON @PFIRSTNAME NVARCHAR(100), @PSURNAME NVARCHAR(100), 
@PEMAIL NVARCHAR(100), @PPASSWORD NVARCHAR(100), @PACCOUNTID INT AS
BEGIN

    BEGIN TRAN
        BEGIN TRY

            IF NOT CHARINDEX('@', @PEMAIL) > 0 -- IF @PEMAIL LIKE '%@%'
                THROW 53003, 'Invalid Email Address', 1
            ELSE
                BEGIN
                    INSERT INTO AUTHORISEDPERSON3778 (FIRSTNAME, SURNAME, EMAIL, [PASSWORD], ACCOUNTID )
                    VALUES (@PFIRSTNAME, @PSURNAME, @PEMAIL, @PPASSWORD, @PACCOUNTID);

                    COMMIT TRAN

                    RETURN @@IDENTITY;
                END
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN

            IF  ERROR_NUMBER() = 53003            
                THROW        
            ELSE
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH

END;
GO

IF OBJECT_ID('MAKE_ACCOUNT_PAYMENT') IS NOT NULL
DROP PROCEDURE MAKE_ACCOUNT_PAYMENT;

GO

--------------------  MAKE_ACCOUNT_PAYMENT  --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- insert the specified values into the table ACCOUNTPAYMENT3778 (USING THE CURRENT SYS DATETIME)
    -- UPDATE THE RELEVANT ACCOUNT IN CLENTACCOUNT3778 TO RELFECT THE BALANCE REDUCED BY THE PAYMENT
    -- UPDATE THE GENERAL LEDGER TO REDUCE ACCOUNT ASSETS BY THE PAYMENT AMOUNT
    -- UPDATE THE GENERAL LEDGER TO INCREASE CASH ASSETS BY THE PAYMENT AMOUNT

    -- EXCEPTIONS
    -- ACCOUNT DOESNT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- PAYMENT AMOUNT IS NEGATIVE (SEE TABLE CONSTRAINTS) THROW ERROR 53004 :   ACCOUNT PAYMENT AMOUNT MUST BE POSITIVE  
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE MAKE_ACCOUNT_PAYMENT @PACCOUNTID INT, @PAMOUNT MONEY AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            
            INSERT INTO ACCOUNTPAYMENT3778 (ACCOUNTID, DATETIMERECEIVED, AMOUNT)
            VALUES (@PACCOUNTID, GETDATE(), @PAMOUNT);

            UPDATE CLIENTACCOUNT3778 SET BALANCE = (BALANCE - @PAMOUNT) 
            WHERE ACCOUNTID = @PACCOUNTID;

            UPDATE GENERALLEDGER3778 SET AMOUNT = (AMOUNT - @PAMOUNT ) 
            WHERE ITEMID = 3;

            UPDATE GENERALLEDGER3778 SET AMOUNT = (AMOUNT + @PAMOUNT ) 
            WHERE ITEMID = 1;

            COMMIT TRAN
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            IF  ERROR_NUMBER() = 547 
                BEGIN
                    IF @PAMOUNT < 0
                        THROW 53004, 'Account Payment Must Be Positive', 1
                    ELSE
                        THROW 53002, 'Account Doesnt Exist', 1
                END
            ELSE
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END
        END CATCH
END;
GO


IF OBJECT_ID('GET_CLIENT_ACCOUNT_BY_ID') IS NOT NULL
DROP PROCEDURE GET_CLIENT_ACCOUNT_BY_ID;

GO

--------------------  GET_CLIENT_ACCOUNT_BY_ID  --------------------

-- return the specified CLIENT ACCOUNT INCLUDING AND ALL AUTHORISED PERSONS DETAILS

    -- EXCEPTIONS
     -- ACCOUNT DOESNT EXIST THROW ERROR 53002 : ACCOUNT DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE GET_CLIENT_ACCOUNT_BY_ID @PACCOUNTID INT, @MyCursor CURSOR VARYING OUTPUT AS
BEGIN
    BEGIN TRY
        IF EXISTS(SELECT * FROM CLIENTACCOUNT3778 WHERE ACCOUNTID = @PACCOUNTID)
            BEGIN
                SET @MyCursor = CURSOR FOR 
                SELECT CLIENTACCOUNT3778.ACCOUNTID, ACCTNAME, BALANCE, CREDITLIMIT, USERID, FIRSTNAME, SURNAME, EMAIL
                FROM CLIENTACCOUNT3778  INNER JOIN AUTHORISEDPERSON3778 
                ON CLIENTACCOUNT3778.ACCOUNTID = AUTHORISEDPERSON3778.ACCOUNTID 
                WHERE CLIENTACCOUNT3778.ACCOUNTID = 30001

                OPEN @MyCursor;
            END
            
    ELSE
        BEGIN
            ;THROW 53002, 'Account Doesnt Exist', 1;
        END
    END TRY
    BEGIN CATCH
            IF  ERROR_NUMBER() = 53002            
                THROW;
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
    END CATCH
    
END;
GO


IF OBJECT_ID('CREATE_ORDER') IS NOT NULL
DROP PROCEDURE CREATE_ORDER;
GO

--------------------  CREATE_ORDER --------------------

    -- insert the specified values into the table ORDER3778
    -- SET THE TOTAL TO 0
    -- RETURN THE NEW ORDERS ORDERID

    -- EXCEPTIONS
    -- USER DOES NOT EXIST : THROW ERROR 55002 : USER DOES NOT EXIST
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE CREATE_ORDER  @PSHIPPINGADDRESS NVARCHAR(200), @PUSERID INT AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            
            INSERT INTO ORDER3778 (SHIPPINGADDRESS, DATETIMECREATED, TOTAL, USERID)
            VALUES (@PSHIPPINGADDRESS, GETDATE(), 0, @PUSERID)

            COMMIT TRAN

            RETURN @@IDENTITY
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            IF  ERROR_NUMBER() = 547            
                THROW 55002, 'User Does Not Exist', 1;
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH
END;
GO

IF OBJECT_ID('GET_ORDER_BY_ID') IS NOT NULL
DROP PROCEDURE GET_ORDER_BY_ID;

GO

--------------------  GET_ORDER_BY_ID --------------------

    -- return the specified ORDER INCLUDING ALL RELATED ORDERLINES

    -- EXCEPTIONS
     -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE GET_ORDER_BY_ID @PORDERID INT, @MyCursor CURSOR VARYING OUTPUT AS
BEGIN
    BEGIN TRY
        IF EXISTS(SELECT * FROM ORDER3778 WHERE ORDERID = @PORDERID)
            BEGIN
                SET @MyCursor = CURSOR FOR 
                SELECT ORDER3778.*, ORDERLINE3778.PRODUCTID, 
                ORDERLINE3778.QUANTITY, ORDERLINE3778.DISCOUNT, ORDERLINE3778.SUBTOTAL
                FROM ORDER3778 INNER JOIN ORDERLINE3778
                ON ORDER3778.ORDERID = ORDERLINE3778.ORDERID
                WHERE ORDER3778.ORDERID = @PORDERID

                OPEN @MyCursor;
            END
    ELSE
        BEGIN
            ;THROW 54002, 'Order Doesnt Exist', 1;
        END
    END TRY
    BEGIN CATCH
            IF  ERROR_NUMBER() = 54002            
                THROW;
            ELSE 
                BEGIN                
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
    END CATCH

END;
GO

IF OBJECT_ID('ADD_PRODUCT_TO_ORDER') IS NOT NULL
DROP PROCEDURE ADD_PRODUCT_TO_ORDER;
GO

--------------------  ADD_PRODUCT_TO_ORDER  --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN
    -- IF THE PRODUCT HAS NOT ALREADY BEEN ADDED TO THAT ORDER (I.E. PK IS UNIQUE)
        -- insert the specified values into the table ORDERLINE3778
        -- CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- ELSE -- the product is aleady in that order 
        -- update the relevant orderline by adding the new quantity to the previous quantity,
        -- RE CALCULATE THE SUBTOTAL VALUE BASED ON THE PRODUCTS SELLPRICE, THE QUANTITY AND THE DISCOUNT
        -- UPDATE THE ORDERS TOTAL - INCREASE IT BY THE VALUE OF THE QTY ADDED TO THE ORDERLINE

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST ----- 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54002 : ORDER HAS ALRADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- DISCOUNT IS OUT OF PERMITTED RANGE (SEE TABLE CONSTRAINTS) THROW ERROR 54004 : DISCOUNT OUT OF RANGE
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE ADD_PRODUCT_TO_ORDER @PORDERID INT, @PPRODIID INT, @PQTY INT, @DISCOUNT DECIMAL(3,2) AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            DECLARE @Price MONEY = (SELECT SELLPRICE FROM PRODUCT3778 WHERE PRODUCTID = @PPRODIID);
            DECLARE @SubTotal MONEY;

            -- Check if Order FullFilled
            IF ((SELECT DATETIMEDISPATCHED FROM ORDER3778 WHERE ORDERID = @PORDERID) IS NOT NULL)
                THROW 54002, 'Order has already been fullfilled', 1;
            -- Check if Product Added to Order
            IF NOT EXISTS(SELECT * FROM ORDERLINE3778 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODIID)
                BEGIN
                    SET @SubTotal = ((@Price * @PQTY) - (@Price * @PQTY * @DISCOUNT));

                    INSERT INTO ORDERLINE3778 (ORDERID, PRODUCTID, QUANTITY, DISCOUNT, SUBTOTAL)
                    VALUES (@PORDERID, @PPRODIID, @PQTY, @DISCOUNT, @SubTotal);

                    UPDATE ORDER3778 SET TOTAL = (TOTAL + @SubTotal) WHERE ORDERID = @PORDERID;
                END
            ELSE
                BEGIN
                    DECLARE @NewQty INT = (SELECT QUANTITY FROM ORDERLINE3778 
                    WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODIID) + @PQTY;
                    
                    SET @SubTotal = ((@Price * @NewQty) - (@Price * @NewQty * @DISCOUNT));

                    UPDATE ORDERLINE3778 SET QUANTITY = @NewQty, DISCOUNT = @DISCOUNT, SUBTOTAL = @SubTotal
                    WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODIID;

                    SET @SubTotal = (SELECT SUM(SUBTOTAL) FROM ORDERLINE3778
                    WHERE ORDERID = @PORDERID) 
                    
                    UPDATE ORDER3778 SET TOTAL = @SubTotal WHERE ORDERID = @PORDERID;
                END
            
            COMMIT TRAN
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            IF ERROR_NUMBER() = 515
                IF NOT EXISTS(SELECT * FROM PRODUCT3778 WHERE PRODUCTID = @PPRODIID)
                        THROW 52002, 'Product Doesnt Exist', 1;
            IF ERROR_NUMBER() = 547
                BEGIN
                    IF NOT EXISTS(SELECT * FROM ORDER3778 WHERE ORDERID = @PORDERID)
                        THROW 54002, 'Order Doesnt Exist', 1;

                    IF(@DISCOUNT < 0 OR @DISCOUNT > 0.25)
                        THROW 54004, 'Discount Out of Range', 1;
                END
            IF ERROR_NUMBER() = 54002           
                THROW;
            ELSE 
                BEGIN              
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH
END;
GO

IF OBJECT_ID('REMOVE_PRODUCT_FROM_ORDER') IS NOT NULL
DROP PROCEDURE REMOVE_PRODUCT_FROM_ORDER;
GO

--------------------  REMOVE_PRODUCT_FROM_ORDER  --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION
    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN
    -- UPDATE THE ORDERS TOTAL - DECREASE IT BY THE VALUE OF THE ORDRLINES SUBTOTAL
    -- DELETE THE RELEVANT ROW FROM ORDERLINE3778

    -- EXCEPTIONS
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54002 : ORDER HAS ALREADY BEEN FULLFILLED
    -- PRODUCT DOES NOT EXIST THROW ERROR 52002 : PRODUCT DOES NOT EXIST
    -- PRODUCT HAS NOT BEEN ADDED TO ORDER THROW ERROR 54005 : PRODUCT NOT ON ORDER
    -- for any other errors throw error : number 50000  message:  error_message()



CREATE PROCEDURE REMOVE_PRODUCT_FROM_ORDER @PORDERID INT, @PPRODIID INT AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            -- Check if Product Exists
            IF NOT EXISTS(SELECT * FROM PRODUCT3778 WHERE  PRODUCTID = @PPRODIID)
                THROW 52002, 'Product Doesnt Exist', 1;
            -- Check if Order Exists 
            IF NOT EXISTS(SELECT * FROM ORDER3778 WHERE ORDERID = @PORDERID)
                THROW 54002, 'Order Doesnt Exist', 1;  
            -- Check if Order FullFilled
            IF ((SELECT DATETIMEDISPATCHED FROM ORDER3778 WHERE ORDERID = @PORDERID) IS NOT NULL)
                THROW 54002, 'Order has already been fullfilled', 1;
            -- Check if Product Added to Order
            IF NOT EXISTS(SELECT * FROM ORDERLINE3778 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODIID)
                THROW 54005, 'Product Not Added to Order', 1;

            DELETE FROM ORDERLINE3778 WHERE ORDERID = @PORDERID AND PRODUCTID = @PPRODIID
            
            DECLARE @SubTotal MONEY = (SELECT SUM(SUBTOTAL) FROM ORDERLINE3778
            WHERE ORDERID = @PORDERID) 

            UPDATE ORDER3778 SET TOTAL = @SubTotal WHERE ORDERID = @PORDERID;

            COMMIT TRAN
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            IF ERROR_NUMBER() = 52002 OR ERROR_NUMBER() = 54002 OR ERROR_NUMBER() = 54005        
                THROW;
            ELSE 
                BEGIN              
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END  
        END CATCH
END;
GO


IF OBJECT_ID('GET_OPEN_ORDERS') IS NOT NULL
DROP PROCEDURE GET_OPEN_ORDERS;
GO

--------------------  GET_OPEN_ORDERS  --------------------

    -- RETURN A CURSOR WHICH REFERENCES ALL CURRENTLY OPEN (NOT FULFILLED) ORDERS

    -- EXCEPTIONS
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE GET_OPEN_ORDERS @MyCursor CURSOR VARYING OUTPUT AS
BEGIN
    BEGIN TRY
        SET @MyCursor = CURSOR FOR SELECT * FROM ORDER3778 WHERE DATETIMEDISPATCHED IS NULL 

        OPEN @MyCursor;
    END TRY
    BEGIN CATCH              
        DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
        THROW 50000, @ERRORMESSAGE, 1    
    END CATCH

END;
GO


IF OBJECT_ID('FULLFILL_ORDER') IS NOT NULL
DROP PROCEDURE FULLFILL_ORDER;
GO

--------------------  FULLFILL_ORDER  COMPLETE  --------------------

    -- THE FOLLOWING MUST BE COMPLETED AS A SINGLE TRANSACTION

    -- CHECK IF THE ORDER HAS ALREADY BEEN FULFILLED (HAS A DATETIMEDISATHCED VALUE)
    -- IF IT HAS BEEN FULFULLILLED GENERATE AN ERROR - SEE EXCEPTIONS SECTION
    -- IF IT HAS NOT BEEN FULLFILLED THEN

    -- UPDATE THE ORDERS DATETIMEDISPATCHED WITH THE CURRENT DATE TIME
    -- ** TRICKY** FOR EACH PRODUCT IN THE ORDER FIND INVENTORY WHICH HAS SUFFICIENT UNITS OF THE PRODUCT IN STOCK 
            -- AND DECREASE THE INVENTORY BY THE AMOUNT OF THE PRODUCT IN TH ORDER
    -- INCREASE THE RELEVANT CLIENTACCOUNTS BALANCE BY THE TOTAL VALUE OF THE ORDER
    -- To Do
    -- INCREASE THE GENERAL LEDGER ACCOUNT ASSETS AMOUNT BY THE TOTAL VALUE OF THE ORDER
    -- ** TRICKY** DECREASE THE GENERAL LEDGER STOCK ASSESTS AMOUNT BY THE WHOLESALE (QTY * BUYPRICE) OF ALL THE PRODUCTS IN THE ORDER

    -- EXCEPTIONS
    -- INSUFFICIENT INVENTORY OF ONE OR MORE PRODUCTS TO FULFILL ORDER THROW ERROR 54006: INSUFFUCIENT INVENTORY TO FULFILL
	-- CLIENT ACCOUNT DOES NOT HAVE SUFFICIENT CREDIT REMAINING TO PAY FOR ORDER THROW ERROR 53005 : INSUFFICIENT CREDIT
    -- ORDER HAS ALREADY BEEN FULFILLED THROW ERROR 54002 : ORDER HAS ALREADY BEEN FULLFILLED
    -- ORDER DOES NOT EXIST THROW ERROR 54002 : ORDER DOES NOT EXIST 
    -- for any other errors throw error : number 50000  message:  error_message()


CREATE PROCEDURE FULLFILL_ORDER @PORDERID INT AS
BEGIN
    BEGIN TRAN
        BEGIN TRY
            -- Check if Order Exists 
            IF NOT EXISTS(SELECT * FROM ORDER3778 WHERE ORDERID = @PORDERID)
                THROW 54002, 'Order Doesnt Exist', 1;  

            -- Check if Order FullFilled
            IF ((SELECT DATETIMEDISPATCHED FROM ORDER3778 WHERE ORDERID = @PORDERID) IS NOT NULL)
                THROW 54002, 'Order has already been fullfilled', 1;

            -- Get Client Account ID
            DECLARE @AccID INT = (SELECT ACCOUNTID FROM AUTHORISEDPERSON3778 INNER JOIN ORDER3778
            ON AUTHORISEDPERSON3778.USERID = ORDER3778.USERID WHERE ORDERID = @PORDERID)

            -- FullFill Order
            UPDATE ORDER3778 SET DATETIMEDISPATCHED = GETDATE() WHERE ORDERID = @PORDERID

            DECLARE @MyCursor CURSOR;
            DECLARE @ProdID INT;
            DECLARE @Qty INT;
            DECLARE @SubTotal MONEY;
            DECLARE @LocID NVARCHAR(10);
            
            SET @MyCursor = CURSOR FOR SELECT PRODUCTID, QUANTITY, SUBTOTAL FROM ORDERLINE3778 WHERE ORDERID = @PORDERID

            OPEN @MyCursor
            FETCH NEXT FROM @MyCursor INTO @ProdID, @Qty, @SubTotal;

            WHILE @@FETCH_STATUS = 0
                BEGIN
                    -- Find Location with highest Stock Level for current PRODUCTID in Cursor
                    SET @LocID = (SELECT TOP 1 LOCATIONID FROM INVENTORY3778 
                    WHERE PRODUCTID = @ProdID ORDER BY NUMINSTOCK DESC);

                    -- Try Update NUMINSTOCK From Location just found with highest stock level
                    UPDATE INVENTORY3778 SET NUMINSTOCK -= @Qty WHERE LOCATIONID = @LocID AND PRODUCTID = @ProdID;

                    -- Update Balance for CLient Account by adding Subtotal of current PRODUCTID in Cursor
                    UPDATE CLIENTACCOUNT3778 SET BALANCE += @SubTotal WHERE ACCOUNTID = @AccID

                    -- Update GENERALLEDGER3778 by increasing the ASSETSACCOUNT Amount by the Subtotal of each OrderLine
                    UPDATE GENERALLEDGER3778 SET AMOUNT += @SubTotal WHERE ITEMID = 3;

                    -- Update GENERALLEDGER3778 by decreasing ASSETSSTOCK by the Quantity & Buy proce of current product on Orderline
                    UPDATE GENERALLEDGER3778 SET AMOUNT -= @Qty * (SELECT BUYPRICE FROM PRODUCT3778 WHERE PRODUCTID = @ProdID) 
                    WHERE ITEMID = 2;

                    FETCH NEXT FROM @MyCursor INTO @ProdID, @Qty, @SubTotal;
                END

            CLOSE @MyCursor ;
            DEALLOCATE @MyCursor;

            COMMIT TRAN
        END TRY
        BEGIN CATCH
            ROLLBACK TRAN
            IF ERROR_NUMBER() = 54002        
                THROW;
            IF ERROR_NUMBER() = 547
                BEGIN
                    IF ((SELECT NUMINSTOCK FROM INVENTORY3778 WHERE LOCATIONID = @LocID AND PRODUCTID = @ProdID) < @Qty)
                        THROW 54006, 'Insufficient Inventory to Fullfill Order', 1;
                    IF((SELECT TOTAL FROM ORDER3778 WHERE ORDERID = @PORDERID) + 
                    (SELECT BALANCE FROM CLIENTACCOUNT3778 WHERE ACCOUNTID = @AccID) >
                    (SELECT CREDITLIMIT FROM CLIENTACCOUNT3778 WHERE ACCOUNTID = @AccID))
                        THROW 53005, 'Insufficient Credit', 1; 
                END
            ELSE 
                BEGIN              
                    DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();          
                    THROW 50000, @ERRORMESSAGE, 1            
                END 
        END CATCH

END;
GO



--###############################################################
-- BELLOW CODE IS AN EXAMPLE ONLY - IT IS NOT PART OF THE TASK
--###############################################################
/*

CREATE PROCEDURE ADD_LOCATION @PCUSTID INT, @PCUSTNAME NVARCHAR(100) AS
BEGIN    
    BEGIN TRY        
        IF @PCUSTID < 1 OR @PCUSTID > 499            
        THROW 50020, 'Customer ID out of range', 1        
        INSERT INTO CUSTOMER (CUSTID, CUSTNAME, SALES_YTD, STATUS)         
        VALUES (@PCUSTID, @PCUSTNAME, 0, 'OK');    
    END TRY    
    BEGIN CATCH        
        if ERROR_NUMBER() = 2627            
            THROW 50010, 'Duplicate customer ID', 1        
        ELSE IF ERROR_NUMBER() = 50020            
            THROW        
        ELSE            
            BEGIN                
                DECLARE @ERRORMESSAGE NVARCHAR(MAX) = ERROR_MESSAGE();                
                THROW 50000, @ERRORMESSAGE, 1            
            END;    
    END CATCH;
END;

GO

EXEC ADD_CUSTOMER @pcustid = 1, @pcustname = 'testdude2';
EXEC ADD_CUSTOMER @pcustid = 500, @pcustname = 'testdude3';select * from customer;

*/